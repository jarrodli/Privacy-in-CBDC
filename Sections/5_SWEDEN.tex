\section{Case Study: Sweden's Riksbank e-krona}

\subsection{Two Tiered System}

As is the case for many countries globally, the use of cash in Sweden is declining [29]. Responding to the increasingly digital nature of the economy, Sweden's central bank, the Riksbank, started exploring the creation of a ``digital supplement to physical cash'' called the e-krona. The e-krona adopts a two-tier model [30]-[31] which consolidates both wholesale CBDC and retail CBDC into a single unified platform for money supply and distribution. 

An e-krona is initially issued by the Riksbank to a limited number of participants, not dissimilar from the central bank reserves accounts architecture outlined in Part II [32]. These participants operate nodes from which they can request e-krona from the Riksbank. In reality, this process debits an amount equal to the amount of e-krona requested from the participant's account via. an RTGS system called RIX. 

Every e-krona is marked with its transaction history, such that the history can be traced back to the original issuer, the Riksbank [30]. An e-krona is spent by first checking its authenticity against a notary node. These notary nodes, operated by the Riksbank, verify both that a token is unspent and that it originates from the Riksbank. After one or more e-krona are spent (or burnt), a new e-krona is transferred to the transferee and any change is returned to the transferor.

\subsection{R3 Corda}

The Riksbank adopts R3's Corda (`Corda') DLT platform for executing e-krona transactions [33]. Similar to AZTEC, Corda allows pseudonym public-private key pairs called \textit{confidential identities}. When a transaction takes place, the recipient verifies that the token is unspent by traversing the transaction graph local to that particular token. The process is known as \textit{partial visibility} since only the nodes involved in the transaction are able to view the token's history. Finally, in order to prove certain statements about a transaction, Corda uses \textit{transaction tear-offs} to reveal part of a transaction to a counter-party.

\textit{Confidential identities}. All identities in Corda are represented by an \texttt{AbstractParty} class [34]. Known identities use a base \texttt{Party} class inheriting \texttt{AbstractParty}. They are identified by an X.509 public key that resolves to an X.500 name. Conversely, anonymous identities use the \texttt{AnonymousParty} class. That class is similar to \texttt{Party} \textit{except} it does not resolve to a well-known X.500 name. More concretely, a pseudonym key pair with public key $A$ and private key $a$ can be generated by a recipient. Confidential identities are ``revealed'' through an interactive protocol whereby a transferee sends a challenge to the transferor in the form of a random nonce. An anonymous transferor can then verify the pseudonym by signing the nonce with $a$ which is validated against the public key of the anonymous party.

\textit{Partial visibility}. Transactions between parties through Corda are not global in the sense that they are broadcast to the entire network [33]. Knowledge of a transaction is constrained to the parties to that transaction. By definition, notary nodes (in this case operated by the Riksbank) have access to the entire ledger because every transaction must be validated against a notary. In general, however, only those participant nodes known to the transferor and transferee are aware of a transaction's existence. 

\textit{Transaction tear-offs}. Sometimes it is useful for a party in the network to demonstrate that the currency they own meets some regulatory requirement. Proving an attribute of the currency satisfies this requirement should leak no more information than the part of the transaction constituting the attribute to be verified. Corda solves this problem by establishing a counterparty, defined as an \textit{oracle}, that signs transactions satisfying some statement [33].

An oracle is presented with a Merkle hash tree with leaves representing a part of the transaction [35]. Suppose that there exist two facts $a = 1$ and $b = 2$ such that a party wishes to prove $a < 10$. Under such conditions, the oracle would receive a tree with a root $h(a + b)$ and leaves $a$ and $h(b)$. As is clear, $b$ is \textit{not} provided because its value is not required to prove the statement in question. If the statement is met by the transaction, the oracle returns the signed root.
